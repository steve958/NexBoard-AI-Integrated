rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    
    // Helper function to get user role
    function getUserRole(projectData, uid) {
      return projectData.ownerId == uid ? 'owner' :
             (projectData.roles != null && uid in projectData.roles) ? projectData.roles[uid] : null;
    }
    
    // Check if user has at least the specified role
    function hasRole(projectData, uid, minRole) {
      let userRole = getUserRole(projectData, uid);
      let roleValues = {'owner': 3, 'editor': 2, 'commenter': 1};
      return userRole != null && roleValues[userRole] >= roleValues[minRole];
    }
    
    match /projects/{projectId} {
      // Create: allow if the creator is the owner and included as a member
      allow create: if request.auth != null
        && request.resource.data.ownerId == request.auth.uid
        && request.auth.uid in request.resource.data.members;
      
      // Read: members can read projects they belong to
      allow read: if request.auth != null && request.auth.uid in resource.data.members;
      
      // Update/Delete: only owner can modify project settings
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.ownerId;
      
      // Columns: editors and owners can manage
      match /columns/{columnId} {
        allow read: if request.auth != null &&
          request.auth.uid in get(/databases/$(db)/documents/projects/$(projectId)).data.members;
        allow write: if request.auth != null &&
          hasRole(get(/databases/$(db)/documents/projects/$(projectId)).data, request.auth.uid, 'editor');
      }
      
      // Tasks: editors can CRUD, commenters can read
      match /tasks/{taskId} {
        allow read: if request.auth != null &&
          request.auth.uid in get(/databases/$(db)/documents/projects/$(projectId)).data.members;
        allow create, update, delete: if request.auth != null &&
          hasRole(get(/databases/$(db)/documents/projects/$(projectId)).data, request.auth.uid, 'editor');
      }
      
      // Comments: commenters can create, authors can update/delete own, editors can moderate
      match /comments/{commentId} {
        allow read: if request.auth != null &&
          request.auth.uid in get(/databases/$(db)/documents/projects/$(projectId)).data.members;
        allow create: if request.auth != null &&
          hasRole(get(/databases/$(db)/documents/projects/$(projectId)).data, request.auth.uid, 'commenter')
          && request.resource.data.authorId == request.auth.uid;
        allow update: if request.auth != null &&
          (resource.data.authorId == request.auth.uid || 
           hasRole(get(/databases/$(db)/documents/projects/$(projectId)).data, request.auth.uid, 'editor'));
        allow delete: if request.auth != null &&
          (resource.data.authorId == request.auth.uid ||
           hasRole(get(/databases/$(db)/documents/projects/$(projectId)).data, request.auth.uid, 'editor'));
      }
      
      // Notifications: users can read their own, system can write
      match /notifications/{notificationId} {
        allow read: if request.auth != null && resource.data.userId == request.auth.uid;
        allow create: if request.auth != null &&
          request.auth.uid in get(/databases/$(db)/documents/projects/$(projectId)).data.members;
        allow update: if request.auth != null && resource.data.userId == request.auth.uid;
      }
    }

    match /users/{uid} {
      // Allow authenticated users to read basic user profiles (minimal PII)
      allow read: if request.auth != null;
      // Only the user can write their own profile
      allow write: if request.auth != null && request.auth.uid == uid;
    }

    match /apiTokens/{tokenId} {
      // Users can only read their own tokens
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      // Users can only create tokens for themselves
      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.userId
        && request.resource.data.label is string
        && request.resource.data.scopes is list
        && request.resource.data.tokenHash is string
        && request.resource.data.salt is string;
      // Users can only update (revoke) their own tokens
      allow update: if request.auth != null
        && request.auth.uid == resource.data.userId
        && request.resource.data.userId == resource.data.userId; // Prevent userId change
      // Users can delete their own tokens
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    match /taskProjects/{projectId} {
      // Users can only read their own task projects
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      // Users can only create task projects where they are the owner
      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.userId
        && request.resource.data.name is string;
      // Users can only update their own task projects
      allow update: if request.auth != null
        && request.auth.uid == resource.data.userId
        && request.resource.data.userId == resource.data.userId; // Prevent userId change
      // Users can delete their own task projects
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }
  }
}
